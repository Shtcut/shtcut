import mongoose from 'mongoose';
import { v4 as uuidv4 } from 'uuid';
import * as dateFns from 'date-fns';
import { Between } from 'typeorm';
import * as _ from 'lodash';
import slugify from 'slugify';
import { CreateErrorBodyFn, Dict, RateLimiterParams } from '../types';
import { LimiterInfo } from 'ratelimiter';
// import * as ms from 'moment';

export abstract class Utils {
  /**
   * The function adds a specified number of hours to the current date and time.
   * @param [hour=1] - The "hour" parameter is an optional parameter that specifies the number of hours
   * to add to the current date and time. If no value is provided, it defaults to 1.
   * @returns a Date object with the hour increased by the specified amount.
   */
  public static addHourToDate(hour = 1) {
    const date = new Date();
    const hours = date.getHours() + hour;
    date.setHours(hours);
    return date;
  }

  /**
   * The function generates a random code of a specified size, consisting of either numbers or
   * alphanumeric characters.
   * @param [size=6] - The size parameter determines the length of the generated code. By default, it
   * is set to 6, but you can change it to any positive integer value to generate a code of that
   * length.
   * @param [alpha=false] - The "alpha" parameter is a boolean value that determines whether the
   * generated code should include alphabetic characters (A-Z, a-z) or only numeric characters (0-9).
   * If "alpha" is set to true, the generated code will include alphabetic characters along with
   * numeric characters. If "
   * @returns a randomly generated code of the specified size.
   */
  public static generateCode(size = 6, alpha = false) {
    const characters = alpha ? '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' : '0123456789';
    const charactersArray = characters.split('');
    let selections = '';
    for (let i = 0; i < size; i++) {
      const index = Math.floor(Math.random() * charactersArray.length);
      selections += charactersArray[index];
      charactersArray.splice(index, 1);
    }
    return selections;
  }

  /**
   * The function generates a unique ID by combining a key with a randomly generated UUID.
   * @param {string} key - The `key` parameter is a string that is used as a prefix for generating a
   * unique ID. If a `key` is provided, it will be used as the prefix. If no `key` is provided, the
   * default value of `'key'` will be used as the prefix.
   * @returns a string that consists of the provided key (or the string 'key' if no key is provided)
   * concatenated with a unique identifier generated by the uuidv4() function.
   */
  public static generateUniqueId(key: string): string {
    return `${key || 'key'}-${uuidv4()}`;
  }

  /**
   * The function checks if a given string is a valid UUID.
   * @param {string} id - The `id` parameter is a string representing a UUID (Universally Unique
   * Identifier).
   * @returns The function `isValidUUID` returns a boolean value.
   */
  public static isValidUUID(id: string): boolean {
    const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
    return regexExp.test(id);
  }

  /**
   * This function takes a string and returns a slugified version of it, converting it to lowercase and
   * replacing spaces with hyphens.
   * @param {string} text - The input text that needs to be converted into a slug format.
   * @returns If the `text` parameter is null, undefined, or empty, then it will return the same value.
   * If the `text` parameter contains spaces, then it will return a slugified version of the text in
   * lowercase. Otherwise, it will return the `text` parameter in lowercase.
   */
  public static slugifyText(text: string) {
    if (text === null || typeof text === 'undefined' || _.isEmpty(text)) {
      return text;
    }
    if (text.indexOf(' ') >= 0) {
      return slugify(text.toLowerCase());
    }
    return text.toLowerCase();
  }

  /**
   * The function updates the verification status of an object by setting the value of a specific key
   * to true and removing the corresponding verification code.
   * @param object - The `object` parameter is an object that contains two properties: `verifications`
   * and `verificationCodes`.
   * @param key - The "key" parameter is a unique identifier used to update a specific verification in
   * the object. It is used as a key to access and update the corresponding verification value in the
   * "verifications" object.
   * @returns an object with two properties: "verificationCodes" and "verifications".
   */
  public static updateVerification(object, key) {
    const verifications = {
      ...object.verifications,
      [key]: true,
    };
    const verificationCodes = _.omit({ ...object.verificationCodes }, [key]);
    return { verificationCodes, verifications };
  }

  /**
   * The function checks if a value is a valid MongoDB ObjectId.
   * @param value - The `value` parameter is the value that needs to be checked if it is a valid
   * MongoDB ObjectId.
   * @returns a boolean value.
   */
  static isObjectId(value): boolean {
    try {
      return value && value.length > 12 && String(new mongoose.Types.ObjectId(value)) === String(value);
    } catch (e) {
      return false;
    }
  }

  /**
   * The function adds a "deleted" property with a value of false to an object.
   * @param {Dict} object - The parameter "object" is a dictionary object.
   * @returns a new object that is a copy of the input object with an additional property "deleted" set
   * to false.
   */
  static conditionWithDelete(object: Dict) {
    return { ...object, deleted: false };
  }

  /**
   * The function converts a value to a MongoDB ObjectId using the mongoose library.
   * @param value - The value parameter is the value that you want to convert to a MongoDB ObjectId.
   * @returns a new instance of the mongoose.Types.ObjectId class, with the value passed as an
   * argument.
   */
  static toObjectId(value) {
    return new mongoose.Types.ObjectId(value);
  }

  /**
   * The function generates a date range for a given date, based on the specified database type.
   * @param {string} date - A string representing a specific date.
   * @param [dbType=NoSQL] - The `dbType` parameter is a string that specifies the type of database
   * being used. It has a default value of `'NoSQL'`, but can be overridden with a different value if
   * needed.
   * @returns an object that represents a date range. The format of the returned object depends on the
   * value of the `dbType` parameter. If `dbType` is set to 'NoSQL', the returned object will have the
   * properties `` and ``, which are used in NoSQL databases to represent less than or equal to
   * and greater than or equal to comparisons. If `
   */
  public static generateSingleDateRange(date: string, dbType = 'NoSQL') {
    const startDate = dateFns.startOfDay(dateFns.parseISO(date));
    const endDate = dateFns.endOfDay(dateFns.parseISO(date));
    return dbType === 'NoSQL' ? { $lte: startDate, $gte: endDate } : Between(startDate, endDate);
  }

  /**
   * The function `toObjectIdValue` takes an array of object IDs and a record object, and returns a new
   * object with the same keys as the input object, but with the values converted to object IDs.
   * @param {string[]} objectIds - An array of string values representing the keys of the properties in
   * the `obj` parameter that need to be converted to ObjectId values.
   * @param obj - The `obj` parameter is an object of type `Record<string, any>`. This means it is an
   * object with string keys and values of any type.
   * @returns an object where the keys are the elements of the `objectIds` array, and the values are
   * the result of calling the `toObjectId` function on the corresponding values in the `obj` object.
   */
  public static toObjectIdValue(objectIds: string[], obj: Record<string, any>) {
    return objectIds.reduce((acc, key) => {
      if (_.has(obj, key)) {
        acc[key] = this.toObjectId(obj[key]);
      }
      return acc;
    }, {});
  }

  /**
   * The function generates a date range based on the input object and database type.
   * @param {any} obj - The `obj` parameter is a JSON string that represents a date range. It should
   * have the following structure:
   * @param [dbType=NoSQL] - The `dbType` parameter is a string that specifies the type of database
   * being used. It has a default value of 'NoSQL', but can be overridden with a different value if
   * needed.
   * @returns The function `generateDateRange` returns either an object or a function call, depending
   * on the value of the `dbType` parameter. If `dbType` is equal to 'NoSQL', it returns an object with
   * two properties: `` and ``, which represent the start and end dates of the date range. If
   * `dbType` is not equal to 'NoSQL',
   */
  public static generateDateRange(obj: any, dbType = 'NoSQL') {
    try {
      const dateRange: any = JSON.parse(obj);
      if (dateRange && dateRange.startDate && dateRange.endDate) {
        const startDate = dateFns.startOfDay(dateFns.parseISO(dateRange.startDate));
        const endDate = dateFns.endOfDay(dateFns.parseISO(dateRange.endDate));
        return dbType === 'NoSQL' ? { $lte: startDate, $gte: endDate } : Between(startDate, endDate);
      }
      return this.generateSingleDateRange(dateRange.startDate || dateRange.endDate || new Date(), dbType);
    } catch (e) {
      throw this.generateSingleDateRange(obj, dbType);
    }
  }

  /**
   * The function cleans up a mobile number by removing leading zeros and adding the country code if
   * necessary.
   * @param mobile - The `mobile` parameter is the mobile number that needs to be cleaned up.
   * @returns the cleaned up mobile number.
   */
  public static cleanUpMobileNumber(mobile) {
    let mobileNo = mobile.toString().trim();
    if (mobile.substring(0, 1) === '0' && mobileNo.length === 11) {
      mobile = `234${mobile.substring(1)}`;
    } else if (mobileNo.substring(0, 1) !== '+') {
      mobileNo = `${mobileNo}`;
    }
    return mobileNo;
  }

  public static isLocalAddress(ip: string) {
    return /^(127\.0\.0\.1|::1|fe80(:1)?::1(%.*)?)$/i.test(ip);
  }

  public static mongoDefaultUpdateProps(obj = {}) {
    return { upsert: true, new: true, ...obj };
  }

  public static defaultErrorBodyCreator(limit: LimiterInfo): CreateErrorBodyFn {
    const delta = (limit.reset * 1000 - Date.now()) | 0;
    // @ts-ignore
    return `Rate limit exceed, retry again later}`;
  }

  /**
   * @param params This is the rate limiter params
   * @returns {Boolean}
   */
  public static isTurnedOff(params: RateLimiterParams[] | [false] | undefined): params is [false] {
    return !!params && params.length === 1 && params[0] === false;
  }
}
